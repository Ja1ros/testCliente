{"ast":null,"code":"/*!\n * FilePondPluginFileValidateType 1.2.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\nconst plugin = ({\n  addFilter,\n  utils\n}) => {\n  // get quick reference to Type utils\n  const {\n    Type,\n    isString,\n    replaceInString,\n    guesstimateMimeType,\n    getExtensionFromFilename,\n    getFilenameFromURL\n  } = utils;\n\n  const mimeTypeMatchesWildCard = (mimeType, wildcard) => {\n    const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n\n    const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n\n    return mimeTypeGroup === wildcardGroup;\n  };\n\n  const isValidMimeType = (acceptedTypes, userInputType) => acceptedTypes.some(acceptedType => {\n    // accepted is wildcard mime type\n    if (/\\*$/.test(acceptedType)) {\n      return mimeTypeMatchesWildCard(userInputType, acceptedType);\n    } // is normal mime type\n\n\n    return acceptedType === userInputType;\n  });\n\n  const getItemType = item => {\n    // if the item is a url we guess the mime type by the extension\n    let type = '';\n\n    if (isString(item)) {\n      const filename = getFilenameFromURL(item);\n      const extension = getExtensionFromFilename(filename);\n\n      if (extension) {\n        type = guesstimateMimeType(extension);\n      }\n    } else {\n      type = item.type;\n    }\n\n    return type;\n  };\n\n  const validateFile = (item, acceptedFileTypes, typeDetector) => {\n    // no types defined, everything is allowed \\o/\n    if (acceptedFileTypes.length === 0) {\n      return true;\n    } // gets the item type\n\n\n    const type = getItemType(item); // no type detector, test now\n\n    if (!typeDetector) {\n      return isValidMimeType(acceptedFileTypes, type);\n    } // use type detector\n\n\n    return new Promise((resolve, reject) => {\n      typeDetector(item, type).then(detectedType => {\n        if (isValidMimeType(acceptedFileTypes, detectedType)) {\n          resolve();\n        } else {\n          reject();\n        }\n      }).catch(reject);\n    });\n  };\n\n  const applyMimeTypeMap = map => acceptedFileType => map[acceptedFileType] === null ? false : map[acceptedFileType] || acceptedFileType; // setup attribute mapping for accept\n\n\n  addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', map => Object.assign(map, {\n    accept: 'acceptedFileTypes'\n  })); // filtering if an item is allowed in hopper\n\n  addFilter('ALLOW_HOPPER_ITEM', (file, {\n    query\n  }) => {\n    // if we are not doing file type validation exit\n    if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n      return true;\n    } // we validate the file against the accepted file types\n\n\n    return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n  }); // called for each file that is loaded\n  // right before it is set to the item state\n  // should return a promise\n\n  addFilter('LOAD_FILE', (file, {\n    query\n  }) => new Promise((resolve, reject) => {\n    if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n      resolve(file);\n      return;\n    }\n\n    const acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES'); // custom type detector method\n\n    const typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE'); // if invalid, exit here\n\n    const validationResult = validateFile(file, acceptedFileTypes, typeDetector);\n\n    const handleRejection = () => {\n      const acceptedFileTypesMapped = acceptedFileTypes.map(applyMimeTypeMap(query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP'))).filter(label => label !== false);\n      const acceptedFileTypesMappedUnique = acceptedFileTypesMapped.filter((item, index) => acceptedFileTypesMapped.indexOf(item) === index);\n      reject({\n        status: {\n          main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n          sub: replaceInString(query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'), {\n            allTypes: acceptedFileTypesMappedUnique.join(', '),\n            allButLastType: acceptedFileTypesMappedUnique.slice(0, -1).join(', '),\n            lastType: acceptedFileTypesMappedUnique[acceptedFileTypesMappedUnique.length - 1]\n          })\n        }\n      });\n    }; // has returned new filename immidiately\n\n\n    if (typeof validationResult === 'boolean') {\n      if (!validationResult) {\n        return handleRejection();\n      }\n\n      return resolve(file);\n    } // is promise\n\n\n    validationResult.then(() => {\n      resolve(file);\n    }).catch(handleRejection);\n  })); // expose plugin\n\n  return {\n    // default options\n    options: {\n      // Enable or disable file type validation\n      allowFileTypeValidation: [true, Type.BOOLEAN],\n      // What file types to accept\n      acceptedFileTypes: [[], Type.ARRAY],\n      // - must be comma separated\n      // - mime types: image/png, image/jpeg, image/gif\n      // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n      // - wildcards: image/*\n      // label to show when a type is not allowed\n      labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n      // nicer label\n      fileValidateTypeLabelExpectedTypes: ['Expects {allButLastType} or {lastType}', Type.STRING],\n      // map mime types to extensions\n      fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n      // Custom function to detect type of file\n      fileValidateTypeDetectType: [null, Type.FUNCTION]\n    }\n  };\n}; // fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\n\n\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\nif (isBrowser) {\n  document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', {\n    detail: plugin\n  }));\n}\n\nexport default plugin;","map":null,"metadata":{},"sourceType":"module"}